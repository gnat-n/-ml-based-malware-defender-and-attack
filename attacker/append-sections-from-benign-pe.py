import lief
import os
import subprocess
import random

def garbageByte():
	#x = "0123456789abcdef"
	#return f'\\x{random.choice(x)}{random.choice(x)}'
	return bytes([random.randint(0, 0)])

def garbageLine():
	xs = b''
	for i in range(1000):
		xs += garbageByte()
		
	return xs
	

def appendGarbage(fileList):
	for x in range(100):
		fileList.append(garbageLine())
		
	return fileList

def appendGarbageintoFile(target_pe_file_path):
    fileList = ""
    with open(target_pe_file_path, 'rb', buffering=0) as file:
        fileList = file.readlines()
        fileList = appendGarbage(fileList)
			
    with open(target_pe_file_path, 'wb') as outFile:
	    for entry in fileList:
		    outFile.write(entry)

def append_imports(source_pe, target_pe):
    for imported_library in source_pe.imports:
        # Check if the library is already in the target's imports; if not, create a new import
        existing_import = next((imp for imp in target_pe.imports if imp.name == imported_library.name), None)
        if existing_import is None:
            new_import = lief.PE.Import()
            new_import.name = imported_library.name
            target_pe.add_import(new_import)
            existing_import = new_import

        # Add new entries from source to target
        for entry in imported_library.entries:
            if entry.is_ordinal:
                # Add by ordinal
                existing_import.add_entry_ordinal(entry.ordinal)
            else:
                # Add by name
                existing_import.add_entry(entry.name)

def compress_file_with_upx(file_path):
    try:
        # Running the UPX command
        result = subprocess.run(['upx', file_path], capture_output=True, text=True, check=True)
        #print("UPX Output:", result.stdout)
        #print("Compression successful!")
        return 1
    except subprocess.CalledProcessError as e:
        #print("Failed to compress:", e)
        #print("Error output:", e.stderr)
        return 0

def append_sections_to_folder(source_exes, target_folder):
    for source_exe in source_exes:
        # Load the source PE file
        source_pe = lief.parse(source_exe)

        file_cnt = 0
        # Loop over all files in the target folder
        for filename in os.listdir(target_folder):
            target_path = os.path.join(target_folder, filename)
            if os.path.isfile(target_path):
                #print(f"Appending sections to {filename}...")
                try:
                    if append_sections(source_pe, target_path):
                        file_cnt +=1
                except Exception as e:
                    print(f"Failed to modify {filename}: {str(e)}")
        print(file_cnt)
        

def append_sections(source_pe, target_exe):
    appendGarbageintoFile(target_exe)

    target_pe = lief.parse(target_exe)

    #append_imports(source_pe, target_pe)

    # Check SizeOfOptionalHeader
    if target_pe.optional_header.sizeof_headers == 0:
        print("Invalid SizeOfOptionalHeader; skipping file.")
        return 0

    # Determine the starting point for new sections
    last_section = target_pe.sections[-1]
    new_virtual_address = last_section.virtual_address + last_section.virtual_size
    section_alignment = target_pe.optional_header.section_alignment
    file_alignment = target_pe.optional_header.file_alignment
    new_virtual_address = (new_virtual_address + section_alignment - 1) // section_alignment * section_alignment

    for section in source_pe.sections:
        # Example: Skip certain sections
        if section.name.startswith(".text") or section.name.startswith(".data"):
            continue

        new_section = lief.PE.Section(section.name)
        new_section.content = section.content
        new_section.virtual_address = new_virtual_address
        new_section.virtual_size = max(len(section.content), section.virtual_size)
        new_section.sizeof_raw_data = ((len(section.content) + file_alignment - 1) // file_alignment) * file_alignment
        new_section.characteristics = section.characteristics

        # Update the virtual address for the next section
        new_virtual_address += (new_section.virtual_size + section_alignment - 1) // section_alignment * section_alignment

        # Add the new section to the target PE
        target_pe.add_section(new_section)

    # Use the LIEF PE builder to rebuild the PE file
    builder = lief.PE.Builder(target_pe)
    builder.build()  # Automatically rebuild sections
    modified_path = os.path.join(os.path.dirname(target_exe), os.path.basename(target_exe))
    builder.write(modified_path)
    
    appendGarbageintoFile(target_exe)
    compress_file_with_upx(modified_path)
    
    return 1
    

# Example usage - specify the source EXE and the target directory
source_exe_path = ["/Users/skpaul/mac-tamu/malware-dataset/Attack/dlls/ntdll.dll"]
target_directory = "/Users/skpaul/mac-tamu/malware-dataset/Attack/evade1"
append_sections_to_folder(source_exe_path, target_directory)